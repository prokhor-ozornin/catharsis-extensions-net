using System.Net;
using System.Net.NetworkInformation;
using System.Runtime.CompilerServices;
using System.Security;
using System.Text;

namespace Catharsis.Commons;

/// <summary>
///   <para>Extension methods for random numbers generators.</para>
/// </summary>
/// <seealso cref="Random"/>
public static class RandomExtensions
{
  /// <summary>
  ///   <para></para>
  /// </summary>
  /// <param name="random"></param>
  /// <param name="min"></param>
  /// <param name="max"></param>
  /// <returns></returns>
  public static sbyte Sbyte(this Random random, sbyte? min = null, sbyte? max = null) => (sbyte) random.Next(min ?? sbyte.MinValue, max ?? sbyte.MaxValue);

  /// <summary>
  ///   <para></para>
  /// </summary>
  /// <param name="random"></param>
  /// <param name="ranges"></param>
  /// <returns></returns>
  public static sbyte SbyteInRange(this Random random, params Range[] ranges)
  {
    switch (ranges.Length)
    {
      case 0:
        return random.Sbyte();

      case 1:
        var range = ranges.First();
        return random.Sbyte((sbyte?) range.Start.Value, (sbyte?) range.End.Value);

      default:
        return (sbyte) ranges.ToRange().Random();
    }
  }

  /// <summary>
  ///   <para></para>
  /// </summary>
  /// <param name="random"></param>
  /// <param name="count"></param>
  /// <param name="min"></param>
  /// <param name="max"></param>
  /// <returns></returns>
  public static IEnumerable<sbyte> SbyteSequence(this Random random, int count, sbyte? min = null, sbyte? max = null) => count.Objects(() => random.Sbyte(min, max));

  /// <summary>
  ///   <para></para>
  /// </summary>
  /// <param name="random"></param>
  /// <param name="count"></param>
  /// <param name="ranges"></param>
  /// <returns></returns>
  public static IEnumerable<sbyte> SbyteSequenceInRange(this Random random, int count, params Range[] ranges)
  {
    if (count <= 0)
    {
      return Enumerable.Empty<sbyte>();
    }

    switch (ranges.Length)
    {
      case 0:
        return random.SbyteSequence(count);

      case 1:
        var range = ranges.First();
        return random.SbyteSequence(count, (sbyte?) range.Start.Value, (sbyte?) range.End.Value);

      default:
        var totalRange = ranges.ToRange();
        return count.Objects(() => (sbyte) totalRange.Random());
    }
  }

  /// <summary>
  ///   <para></para>
  /// </summary>
  /// <param name="random"></param>
  /// <param name="min"></param>
  /// <param name="max"></param>
  /// <returns></returns>
  public static byte Byte(this Random random, byte? min = null, byte? max = null) => (byte) random.Next(min ?? byte.MinValue, max ?? byte.MaxValue);

  /// <summary>
  ///   <para></para>
  /// </summary>
  /// <param name="random"></param>
  /// <param name="ranges"></param>
  /// <returns></returns>
  public static byte ByteInRange(this Random random, params Range[] ranges)
  {
    switch (ranges.Length)
    {
      case 0:
        return random.Byte();

      case 1:
        var range = ranges.First();
        return random.Byte((byte?) range.Start.Value, (byte?) range.End.Value);

      default:
        return (byte) ranges.ToRange().Random();
    }
  }

  /// <summary>
  ///   <para>Generates specified number of random bytes.</para>
  /// </summary>
  /// <param name="random">Randomization object that is being extended.</param>
  /// <param name="count">Number of bytes to generate.</param>
  /// <param name="min"></param>
  /// <param name="max"></param>
  /// <returns>Array of randomly generated bytes. Length of array is equal to <paramref name="count"/>.</returns>
  public static IEnumerable<byte> ByteSequence(this Random random, int count, byte? min = null, byte? max = null) => count.Objects(() => random.Byte(min, max));

  /// <summary>
  ///   <para></para>
  /// </summary>
  /// <param name="random"></param>
  /// <param name="count"></param>
  /// <param name="ranges"></param>
  /// <returns></returns>
  public static IEnumerable<byte> ByteSequenceInRange(this Random random, int count, params Range[] ranges)
  {
    if (count <= 0)
    {
      return Enumerable.Empty<byte>();
    }

    switch (ranges.Length)
    {
      case 0:
        return random.ByteSequence(count);

      case 1:
        var range = ranges.First();
        return random.ByteSequence(count, (byte?) range.Start.Value, (byte?) range.End.Value);

      default:
        var totalRange = ranges.ToRange();
        return count.Objects(() => (byte) totalRange.Random());
    }
  }

  /// <summary>
  ///   <para></para>
  /// </summary>
  /// <param name="random"></param>
  /// <param name="min"></param>
  /// <param name="max"></param>
  /// <returns></returns>
  public static short Short(this Random random, short? min = null, short? max = null) => (short) random.Next(min ?? short.MinValue, max ?? short.MaxValue);

  /// <summary>
  ///   <para></para>
  /// </summary>
  /// <param name="random"></param>
  /// <param name="ranges"></param>
  /// <returns></returns>
  public static short ShortInRange(this Random random, params Range[] ranges)
  {
    switch (ranges.Length)
    {
      case 0:
        return random.Short();

      case 1:
        var range = ranges.First();
        return random.Short((short?) range.Start.Value, (short?) range.End.Value);

      default:
        return (short) ranges.ToRange().Random();
    }
  }

  /// <summary>
  ///   <para></para>
  /// </summary>
  /// <param name="random"></param>
  /// <param name="count"></param>
  /// <param name="min"></param>
  /// <param name="max"></param>
  /// <returns></returns>
  public static IEnumerable<short> ShortSequence(this Random random, int count, short? min = null, short? max = null) => count.Objects(() => random.Short(min, max));

  /// <summary>
  ///   <para></para>
  /// </summary>
  /// <param name="random"></param>
  /// <param name="count"></param>
  /// <param name="ranges"></param>
  /// <returns></returns>
  public static IEnumerable<short> ShortSequenceInRange(this Random random, int count, params Range[] ranges)
  {
    if (count <= 0)
    {
      return Enumerable.Empty<short>();
    }

    switch (ranges.Length)
    {
      case 0:
        return random.ShortSequence(count);

      case 1:
        var range = ranges.First();
        return random.ShortSequence(count, (short?) range.Start.Value, (short?) range.End.Value);

      default:
        var totalRange = ranges.ToRange();
        return count.Objects(() => (short) totalRange.Random());
    }
  }

  /// <summary>
  ///   <para></para>
  /// </summary>
  /// <param name="random"></param>
  /// <param name="min"></param>
  /// <param name="max"></param>
  /// <returns></returns>
  public static ushort Ushort(this Random random, ushort? min = null, ushort? max = null) => (ushort) random.Next(min ?? ushort.MinValue, max ?? ushort.MaxValue);

  /// <summary>
  ///   <para></para>
  /// </summary>
  /// <param name="random"></param>
  /// <param name="ranges"></param>
  /// <returns></returns>
  public static ushort UshortInRange(this Random random, params Range[] ranges)
  {
    switch (ranges.Length)
    {
      case 0:
        return random.Ushort();

      case 1:
        var range = ranges.First();
        return random.Ushort((ushort?) range.Start.Value, (ushort?) range.End.Value);

      default:
        return (ushort) ranges.ToRange().Random();
    }
  }

  /// <summary>
  ///   <para></para>
  /// </summary>
  /// <param name="random"></param>
  /// <param name="count"></param>
  /// <param name="min"></param>
  /// <param name="max"></param>
  /// <returns></returns>
  public static IEnumerable<ushort> UshortSequence(this Random random, int count, ushort? min = null, ushort? max = null) => count.Objects(() => random.Ushort(min, max));

  /// <summary>
  ///   <para></para>
  /// </summary>
  /// <param name="random"></param>
  /// <param name="count"></param>
  /// <param name="ranges"></param>
  /// <returns></returns>
  public static IEnumerable<ushort> UshortSequenceInRange(this Random random, int count, params Range[] ranges)
  {
    if (count <= 0)
    {
      return Enumerable.Empty<ushort>();
    }

    switch (ranges.Length)
    {
      case 0:
        return random.UshortSequence(count);

      case 1:
        var range = ranges.First();
        return random.UshortSequence(count, (ushort?) range.Start.Value, (ushort?) range.End.Value);

      default:
        var totalRange = ranges.ToRange();
        return count.Objects(() => (ushort) totalRange.Random());
    }
  }

  /// <summary>
  ///   <para></para>
  /// </summary>
  /// <param name="random"></param>
  /// <param name="min"></param>
  /// <param name="max"></param>
  /// <returns></returns>
  public static int Int(this Random random, int? min = null, int? max = null) => random.Next(min ?? int.MinValue, max ?? int.MaxValue);

  /// <summary>
  ///   <para></para>
  /// </summary>
  /// <param name="random"></param>
  /// <param name="ranges"></param>
  /// <returns></returns>
  public static int IntInRange(this Random random, params Range[] ranges)
  {
    switch (ranges.Length)
    {
      case 0:
        return random.Int();

      case 1:
        var range = ranges.First();
        return random.Int(range.Start.Value, range.End.Value);

      default:
        return ranges.ToRange().Random();
    }
  }

  /// <summary>
  ///   <para></para>
  /// </summary>
  /// <param name="random"></param>
  /// <param name="count"></param>
  /// <param name="min"></param>
  /// <param name="max"></param>
  /// <returns></returns>
  public static IEnumerable<int> IntSequence(this Random random, int count, int? min = null, int? max = null) => count.Objects(() => random.Int(min, max));

  /// <summary>
  ///   <para></para>
  /// </summary>
  /// <param name="random"></param>
  /// <param name="count"></param>
  /// <param name="ranges"></param>
  /// <returns></returns>
  public static IEnumerable<int> IntSequenceInRange(this Random random, int count, params Range[] ranges)
  {
    if (count <= 0)
    {
      return Enumerable.Empty<int>();
    }

    switch (ranges.Length)
    {
      case 0:
        return random.IntSequence(count);

      case 1:
        var range = ranges.First();
        return random.IntSequence(count, range.Start.Value, range.End.Value);

      default:
        var totalRange = ranges.ToRange();
        return count.Objects(() => totalRange.Random());
    }
  }

#if NET6_0
  /// <summary>
  ///   <para></para>
  /// </summary>
  /// <param name="random"></param>
  /// <param name="min"></param>
  /// <param name="max"></param>
  /// <returns></returns>
  public static uint Uint(this Random random, uint? min = null, uint? max = null) => (uint) random.Long(min, max);

  /// <summary>
  ///   <para></para>
  /// </summary>
  /// <param name="random"></param>
  /// <param name="ranges"></param>
  /// <returns></returns>
  public static uint UintInRange(this Random random, params Range[] ranges) => (uint) random.LongInRange(ranges);

  /// <summary>
  ///   <para></para>
  /// </summary>
  /// <param name="random"></param>
  /// <param name="count"></param>
  /// <param name="min"></param>
  /// <param name="max"></param>
  /// <returns></returns>
  public static IEnumerable<uint> UintSequence(this Random random, int count, uint? min = null, uint? max = null) => count.Objects(() => random.Uint(min, max));

  /// <summary>
  ///   <para></para>
  /// </summary>
  /// <param name="random"></param>
  /// <param name="count"></param>
  /// <param name="ranges"></param>
  /// <returns></returns>
  public static IEnumerable<uint> UintSequenceInRange(this Random random, int count, params Range[] ranges)
  {
    if (count <= 0)
    {
      return Enumerable.Empty<uint>();
    }

    switch (ranges.Length)
    {
      case 0:
        return random.UintSequence(count);

      case 1:
        var range = ranges.First();
        return random.UintSequence(count, (uint?) range.Start.Value, (uint?) range.End.Value);

      default:
        var totalRange = ranges.ToRange();
        return count.Objects(() => (uint) totalRange.Random());
    }
  }

  /// <summary>
  ///   <para></para>
  /// </summary>
  /// <param name="random"></param>
  /// <param name="min"></param>
  /// <param name="max"></param>
  /// <returns></returns>
  public static long Long(this Random random, long? min = null, long? max = null) => random.NextInt64(min ?? long.MinValue, max ?? long.MaxValue);

  /// <summary>
  ///   <para></para>
  /// </summary>
  /// <param name="random"></param>
  /// <param name="ranges"></param>
  /// <returns></returns>
  public static long LongInRange(this Random random, params Range[] ranges)
  {
    switch (ranges.Length)
    {
      case 0:
        return random.Long();

      case 1:
        var range = ranges.First();
        return random.Long(range.Start.Value, range.End.Value);

      default:
        return ranges.ToRange().Random();
    }
  }

  /// <summary>
  ///   <para></para>
  /// </summary>
  /// <param name="random"></param>
  /// <param name="count"></param>
  /// <param name="min"></param>
  /// <param name="max"></param>
  /// <returns></returns>
  public static IEnumerable<long> LongSequence(this Random random, int count, long? min = null, long? max = null) => count.Objects(() => random.Long(min, max));

  /// <summary>
  ///   <para></para>
  /// </summary>
  /// <param name="random"></param>
  /// <param name="count"></param>
  /// <param name="ranges"></param>
  /// <returns></returns>
  public static IEnumerable<long> LongSequenceInRange(this Random random, int count, params Range[] ranges)
  {
    if (count <= 0)
    {
      return Enumerable.Empty<long>();
    }

    switch (ranges.Length)
    {
      case 0:
        return random.LongSequence(count);

      case 1:
        var range = ranges.First();
        return random.LongSequence(count, range.Start.Value, range.End.Value);

      default:
        var totalRange = ranges.ToRange();
        return count.Objects(() => (long) totalRange.Random());
    }
  }

  /// <summary>
  ///   <para></para>
  /// </summary>
  /// <param name="random"></param>
  /// <returns></returns>
  public static float Float(this Random random) => random.NextSingle();

  /// <summary>
  ///   <para></para>
  /// </summary>
  /// <param name="random"></param>
  /// <param name="count"></param>
  /// <returns></returns>
  public static IEnumerable<float> FloatSequence(this Random random, int count) => count.Objects(random.Float);
#endif

  /// <summary>
  ///   <para></para>
  /// </summary>
  /// <param name="random"></param>
  /// <returns></returns>
  public static double Double(this Random random) => random.NextDouble();

  /// <summary>
  ///   <para></para>
  /// </summary>
  /// <param name="random"></param>
  /// <param name="count"></param>
  /// <returns></returns>
  public static IEnumerable<double> DoubleSequence(this Random random, int count) => count.Objects(random.Double);

  /// <summary>
  ///   <para></para>
  /// </summary>
  /// <param name="random"></param>
  /// <param name="min"></param>
  /// <param name="max"></param>
  /// <returns></returns>
  public static char Char(this Random random, char? min = null, char? max = null) => (char) random.Next(min ?? char.MinValue, max ?? char.MaxValue);

  /// <summary>
  ///   <para></para>
  /// </summary>
  /// <param name="random"></param>
  /// <param name="ranges"></param>
  /// <returns></returns>
  public static char CharInRange(this Random random, params Range[] ranges)
  {
    switch (ranges.Length)
    {
      case 0:
        return random.Char();

      case 1:
        var range = ranges.First();
        return random.Char((char?) range.Start.Value, (char?) range.End.Value);

      default:
        return (char) ranges.ToRange().Random();
    }
  }

  /// <summary>
  ///   <para></para>
  /// </summary>
  /// <param name="random"></param>
  /// <param name="count"></param>
  /// <param name="min"></param>
  /// <param name="max"></param>
  /// <returns></returns>
  public static IEnumerable<char> CharSequence(this Random random, int count, char? min = null, char? max = null) => count.Objects(() => random.Char(min, max));

  /// <summary>
  ///   <para></para>
  /// </summary>
  /// <param name="random"></param>
  /// <param name="count"></param>
  /// <param name="ranges"></param>
  /// <returns></returns>
  public static IEnumerable<char> CharSequenceInRange(this Random random, int count, params Range[] ranges)
  {
    if (count <= 0)
    {
      return Enumerable.Empty<char>();
    }

    switch (ranges.Length)
    {
      case 0:
        return random.CharSequence(count);

      case 1:
        var range = ranges.First();
        return random.CharSequence(count, (char?) range.Start.Value, (char?) range.End.Value);

      default:
        var totalRange = ranges.ToRange();
        return count.Objects(() => (char) totalRange.Random());
    }
  }

  /// <summary>
  ///   <para></para>
  /// </summary>
  /// <param name="random"></param>
  /// <param name="count"></param>
  /// <param name="min"></param>
  /// <param name="max"></param>
  /// <returns></returns>
  public static string String(this Random random, int count, char? min = null, char? max = null) => count > 0 ? random.CharSequence(count, min, max).AsArray().ToText() : string.Empty;

  /// <summary>
  ///   <para></para>
  /// </summary>
  /// <param name="random"></param>
  /// <param name="count"></param>
  /// <param name="ranges"></param>
  /// <returns></returns>
  public static string StringInRange(this Random random, int count, params Range[] ranges)
  {
    if (count <= 0)
    {
      return string.Empty;
    }
    
    switch (ranges.Length)
    {
      case 0:
        return random.String(count);

      case 1:
        var range = ranges.First();
        return random.String(count, (char?) range.Start.Value, (char?) range.End.Value);

      default:
        var totalRange = ranges.ToRange();
        var chars = count.Objects(() => (char) totalRange.Random());
        return chars.AsArray().ToText();
    }
  }

  /// <summary>
  ///   <para></para>
  /// </summary>
  /// <param name="random"></param>
  /// <param name="size"></param>
  /// <param name="count"></param>
  /// <param name="min"></param>
  /// <param name="max"></param>
  /// <returns></returns>
  public static IEnumerable<string> StringSequence(this Random random, int size, int count, char? min = null, char? max = null) => count.Objects(() => random.String(size, min, max));

  /// <summary>
  ///   <para></para>
  /// </summary>
  /// <param name="random"></param>
  /// <param name="size"></param>
  /// <param name="count"></param>
  /// <param name="ranges"></param>
  /// <returns></returns>
  public static IEnumerable<string> StringSequenceInRange(this Random random, int size, int count, params Range[] ranges)
  {
    if (count <= 0)
    {
      return Enumerable.Empty<string>();
    }

    switch (ranges.Length)
    {
      case 0:
        return random.StringSequence(size, count);

      case 1:
        var range = ranges.First();
        return random.StringSequence(size, count, (char?) range.Start.Value, (char?) range.End.Value);

      default:
        var totalRange = ranges.ToRange();
        return count.Objects(() => new char[size].Fill(() => (char) totalRange.Random()).AsArray().ToText());
    }
  }

  /// <summary>
  ///   <para></para>
  /// </summary>
  /// <param name="random"></param>
  /// <param name="count"></param>
  /// <returns></returns>
  public static string Digits(this Random random, int count) => random.StringInRange(count, '0'..'9');

  /// <summary>
  ///   <para></para>
  /// </summary>
  /// <param name="random"></param>
  /// <param name="size"></param>
  /// <param name="count"></param>
  /// <returns></returns>
  public static IEnumerable<string> DigitsSequence(this Random random, int size, int count) => count.Objects(() => random.Digits(size));

  /// <summary>
  ///   <para></para>
  /// </summary>
  /// <param name="random"></param>
  /// <param name="count"></param>
  /// <returns></returns>
  public static string Letters(this Random random, int count) => random.StringInRange(count, 'a'..'z', 'A'..'Z');

  /// <summary>
  ///   <para></para>
  /// </summary>
  /// <param name="random"></param>
  /// <param name="size"></param>
  /// <param name="count"></param>
  /// <returns></returns>
  public static IEnumerable<string> LettersSequence(this Random random, int size, int count) => count.Objects(() => random.Letters(size));

  /// <summary>
  ///   <para></para>
  /// </summary>
  /// <param name="random"></param>
  /// <param name="count"></param>
  /// <returns></returns>
  public static string AlphaDigits(this Random random, int count) => random.StringInRange(count, 'a'..'z', 'A'..'Z', '0'..'9');

  /// <summary>
  ///   <para></para>
  /// </summary>
  /// <param name="random"></param>
  /// <param name="size"></param>
  /// <param name="count"></param>
  /// <returns></returns>
  public static IEnumerable<string> AlphaDigitsSequence(this Random random, int size, int count) => count.Objects(() => random.AlphaDigits(size));

  /// <summary>
  ///   <para></para>
  /// </summary>
  /// <param name="random"></param>
  /// <param name="count"></param>
  /// <param name="min"></param>
  /// <param name="max"></param>
  /// <returns></returns>
  public static SecureString SecureString(this Random random, int count, char? min = null, char? max = null)
  {
    if (count <= 0)
    {
      return new SecureString();
    }

    var result = new SecureString();

    count.Times(() => result.AppendChar(random.Char(min, max)));

    return result;
  }

  /// <summary>
  ///   <para></para>
  /// </summary>
  /// <param name="random"></param>
  /// <param name="count"></param>
  /// <param name="ranges"></param>
  /// <returns></returns>
  public static SecureString SecureStringInRange(this Random random, int count, params Range[] ranges)
  {
    if (count <= 0)
    {
      return new SecureString();
    }

    switch (ranges.Length)
    {
      case 0:
        return random.SecureString(count);

      case 1:
        var range = ranges.First();
        return random.SecureString(count, (char?) range.Start.Value, (char?) range.End.Value);

      default:
        var result = new SecureString();
        var totalRange = ranges.ToRange();
       
        count.Times(() => result.AppendChar((char) totalRange.Random()));
        
        return result;
    }
  }

  /// <summary>
  ///   <para></para>
  /// </summary>
  /// <param name="random"></param>
  /// <param name="size"></param>
  /// <param name="count"></param>
  /// <param name="min"></param>
  /// <param name="max"></param>
  /// <returns></returns>
  public static IEnumerable<SecureString> SecureStringSequence(this Random random, int size, int count, char? min = null, char? max = null) => count.Objects(() => random.SecureString(size, min, max));

  /// <summary>
  ///   <para></para>
  /// </summary>
  /// <param name="random"></param>
  /// <param name="size"></param>
  /// <param name="count"></param>
  /// <param name="ranges"></param>
  /// <returns></returns>
  public static IEnumerable<SecureString> SecureStringSequenceInRange(this Random random, int size, int count, params Range[] ranges)
  {
    if (count <= 0)
    {
      return Enumerable.Empty<SecureString>();
    }

    switch (ranges.Length)
    {
      case 0:
        return random.SecureStringSequence(size, count);

      case 1:
        var range = ranges.First();
        return random.SecureStringSequence(size, count, (char?) range.Start.Value, (char?) range.End.Value);

      default:
        var totalRange = ranges.ToRange();

        return count.Objects(() =>
        {
          var secure = new SecureString();
          size.Times(() => secure.AppendChar((char) totalRange.Random()));
          return secure;
        });
    }
  }

#if NET6_0
  /// <summary>
  ///   <para></para>
  /// </summary>
  /// <param name="random"></param>
  /// <param name="min"></param>
  /// <param name="max"></param>
  /// <returns></returns>
  public static DateTime DateTime(this Random random, DateTime? min = null, DateTime? max = null) => new(random.Long((min ?? System.DateTime.MinValue).Ticks, (max ?? System.DateTime.MaxValue).Ticks), DateTimeKind.Utc);

  /// <summary>
  ///   <para></para>
  /// </summary>
  /// <param name="random"></param>
  /// <param name="count"></param>
  /// <param name="min"></param>
  /// <param name="max"></param>
  /// <returns></returns>
  public static IEnumerable<DateTime> DateTimeSequence(this Random random, int count, DateTime? min = null, DateTime? max = null) => count.Objects(() => random.DateTime(min,  max));

  /// <summary>
  ///   <para></para>
  /// </summary>
  /// <param name="random"></param>
  /// <param name="min"></param>
  /// <param name="max"></param>
  /// <returns></returns>
  public static DateTimeOffset DateTimeOffset(this Random random, DateTimeOffset? min = null, DateTimeOffset? max = null) => new(random.Long((min ?? System.DateTimeOffset.MinValue).Ticks, (max ?? System.DateTimeOffset.MaxValue).Ticks), TimeSpan.Zero);

  /// <summary>
  ///   <para></para>
  /// </summary>
  /// <param name="random"></param>
  /// <param name="count"></param>
  /// <param name="min"></param>
  /// <param name="max"></param>
  /// <returns></returns>
  public static IEnumerable<DateTimeOffset> DateTimeOffsetSequence(this Random random, int count, DateTimeOffset? min = null, DateTimeOffset? max = null) => count.Objects(() => random.DateTimeOffset(min, max));

  /// <summary>
  ///   <para></para>
  /// </summary>
  /// <param name="random"></param>
  /// <param name="min"></param>
  /// <param name="max"></param>
  /// <returns></returns>
  public static DateOnly DateOnly(this Random random, DateOnly? min = null, DateOnly? max = null) => random.DateTime(min?.ToDateTime(System.TimeOnly.MinValue), max?.ToDateTime(System.TimeOnly.MaxValue)).ToDateOnly();

  /// <summary>
  ///   <para></para>
  /// </summary>
  /// <param name="random"></param>
  /// <param name="count"></param>
  /// <param name="min"></param>
  /// <param name="max"></param>
  /// <returns></returns>
  public static IEnumerable<DateOnly> DateOnlySequence(this Random random, int count, DateOnly? min = null, DateOnly? max = null) => count.Objects(() => random.DateOnly(min, max));

  /// <summary>
  ///   <para></para>
  /// </summary>
  /// <param name="random"></param>
  /// <param name="min"></param>
  /// <param name="max"></param>
  /// <returns></returns>
  public static TimeOnly TimeOnly(this Random random, TimeOnly? min = null, TimeOnly? max = null) => System.TimeOnly.FromTimeSpan(TimeSpan.FromTicks(random.Long((min ?? System.TimeOnly.MinValue).Ticks, (max ?? System.TimeOnly.MaxValue).Ticks)));

  /// <summary>
  ///   <para></para>
  /// </summary>
  /// <param name="random"></param>
  /// <param name="count"></param>
  /// <param name="min"></param>
  /// <param name="max"></param>
  /// <returns></returns>
  public static IEnumerable<TimeOnly> TimeOnlySequence(this Random random, int count, TimeOnly? min = null, TimeOnly? max = null) => count.Objects(() => random.TimeOnly(min, max));
#endif

  /// <summary>
  ///   <para></para>
  /// </summary>
  /// <param name="random"></param>
  /// <param name="max"></param>
  /// <returns></returns>
  public static Range Range(this Random random, int? max = null) => System.Range.EndAt(Index.FromStart(random.Int(0, max)));

  /// <summary>
  ///   <para></para>
  /// </summary>
  /// <param name="random"></param>
  /// <param name="count"></param>
  /// <param name="max"></param>
  /// <returns></returns>
  public static IEnumerable<Range> RangeSequence(this Random random, int count, int? max = null) => count.Objects(() => random.Range(max));

  /// <summary>
  ///   <para></para>
  /// </summary>
  /// <param name="random"></param>
  /// <returns></returns>
  public static Guid Guid(this Random random) => System.Guid.NewGuid();

  /// <summary>
  ///   <para></para>
  /// </summary>
  /// <param name="random"></param>
  /// <param name="count"></param>
  /// <returns></returns>
  public static IEnumerable<Guid> GuidSequence(this Random random, int count) => count.Objects(random.Guid);

  /// <summary>
  ///   <para></para>
  /// </summary>
  /// <param name="random"></param>
  /// <param name="types"></param>
  /// <returns></returns>
  public static object Object(this Random random, IEnumerable<Type> types) => types.IsEmpty() ? new object() : types.Random()!.Instance()!;

  /// <summary>
  ///   <para></para>
  /// </summary>
  /// <param name="random"></param>
  /// <param name="types"></param>
  /// <returns></returns>
  public static object Object(this Random random, params Type[] types) => random.Object(types as IEnumerable<Type>);

  /// <summary>
  ///   <para></para>
  /// </summary>
  /// <param name="random"></param>
  /// <param name="count"></param>
  /// <param name="types"></param>
  /// <returns></returns>
  public static IEnumerable<object> ObjectSequence(this Random random, int count, IEnumerable<Type> types) => count.Objects(() => random.Object(types));

  /// <summary>
  ///   <para></para>
  /// </summary>
  /// <param name="random"></param>
  /// <param name="count"></param>
  /// <param name="types"></param>
  /// <returns></returns>
  public static IEnumerable<object> ObjectSequence(this Random random, int count, params Type[] types) => random.ObjectSequence(count, types as IEnumerable<Type>);

  /// <summary>
  ///   <para></para>
  /// </summary>
  /// <param name="random"></param>
  /// <returns></returns>
  public static string FileName(this Random random) => Path.GetRandomFileName();

  /// <summary>
  ///   <para></para>
  /// </summary>
  /// <param name="random"></param>
  /// <param name="count"></param>
  /// <returns></returns>
  public static IEnumerable<string> FileNameSequence(this Random random, int count) => count.Objects(random.FileName);

  /// <summary>
  ///   <para></para>
  /// </summary>
  /// <param name="random"></param>
  /// <returns></returns>
  public static string DirectoryName(this Random random) => System.Guid.NewGuid().ToString("N");

  /// <summary>
  ///   <para></para>
  /// </summary>
  /// <param name="random"></param>
  /// <param name="count"></param>
  /// <returns></returns>
  public static IEnumerable<string> DirectoryNameSequence(this Random random, int count) => count.Objects(random.DirectoryName);

  /// <summary>
  ///   <para></para>
  /// </summary>
  /// <param name="random"></param>
  /// <param name="directory"></param>
  /// <returns></returns>
  public static string FilePath(this Random random, DirectoryInfo directory = null) => Path.Combine(directory?.FullName ?? Path.GetTempPath(), random.FileName());

  /// <summary>
  ///   <para></para>
  /// </summary>
  /// <param name="random"></param>
  /// <param name="count"></param>
  /// <param name="directory"></param>
  /// <returns></returns>
  public static IEnumerable<string> FilePathSequence(this Random random, int count, DirectoryInfo directory = null) => count.Objects(() => random.FilePath(directory));

  /// <summary>
  ///   <para></para>
  /// </summary>
  /// <param name="random"></param>
  /// <param name="parent"></param>
  /// <returns></returns>
  public static string DirectoryPath(this Random random, DirectoryInfo parent = null) => Path.Combine(parent?.FullName ?? Path.GetTempPath(), random.DirectoryName());

  /// <summary>
  ///   <para></para>
  /// </summary>
  /// <param name="random"></param>
  /// <param name="count"></param>
  /// <param name="parent"></param>
  /// <returns></returns>
  public static IEnumerable<string> DirectoryPathSequence(this Random random, int count, DirectoryInfo parent = null) => count.Objects(() => random.DirectoryPath(parent));

  /// <summary>
  ///   <para></para>
  /// </summary>
  /// <param name="random"></param>
  /// <param name="parent"></param>
  /// <returns></returns>
  public static DirectoryInfo Directory(this Random random, DirectoryInfo parent = null) => System.IO.Directory.CreateDirectory(Path.Combine(parent?.FullName ?? Path.GetTempPath(), System.Guid.NewGuid().ToString("N")));

  /// <summary>
  ///   <para></para>
  /// </summary>
  /// <param name="random"></param>
  /// <param name="count"></param>
  /// <param name="parent"></param>
  /// <returns></returns>
  public static IEnumerable<DirectoryInfo> DirectorySequence(this Random random, int count, DirectoryInfo parent = null) => count.Objects(() => random.Directory(parent));

  /// <summary>
  ///   <para></para>
  /// </summary>
  /// <param name="random"></param>
  /// <param name="directory"></param>
  /// <returns></returns>
  public static FileInfo File(this Random random, DirectoryInfo directory = null) => Path.Combine(directory?.FullName ?? Path.GetTempPath(), random.FileName()).ToFile().CreateWithPath();

  /// <summary>
  ///   <para></para>
  /// </summary>
  /// <param name="random"></param>
  /// <param name="count"></param>
  /// <param name="directory"></param>
  /// <returns></returns>
  public static IEnumerable<FileInfo> FileSequence(this Random random, int count, DirectoryInfo directory = null) => count.Objects(() => random.File(directory));

  /// <summary>
  ///   <para></para>
  /// </summary>
  /// <param name="random"></param>
  /// <param name="size"></param>
  /// <param name="min"></param>
  /// <param name="max"></param>
  /// <param name="directory"></param>
  /// <param name="cancellation"></param>
  /// <returns></returns>
  public static async Task<FileInfo> BinaryFile(this Random random, int size, byte? min = null, byte? max = null, DirectoryInfo directory = null, CancellationToken cancellation = default)
  {
    if (size <= 0)
    {
      return random.File(directory);
    }

    var bytes = random.ByteSequence(size, min, max);
    
    var file = random.File(directory);

    try
    {
      await bytes.WriteTo(file, cancellation);
    }
    catch
    {
      file.Delete();
    }

    return file;
  }

  /// <summary>
  ///   <para></para>
  /// </summary>
  /// <param name="random"></param>
  /// <param name="size"></param>
  /// <param name="directory"></param>
  /// <param name="cancellation"></param>
  /// <param name="ranges"></param>
  /// <returns></returns>
  public static async Task<FileInfo> BinaryFileInRange(this Random random, int size, DirectoryInfo directory = null, CancellationToken cancellation = default, params Range[] ranges)
  {
    if (size <= 0)
    {
      return await random.BinaryFile(size, null, null, directory, cancellation);
    }

    switch (ranges.Length)
    {
      case 0:
        return await random.BinaryFile(size, null, null, directory, cancellation);

      case 1:
        var range = ranges.First();
        return await random.BinaryFile(size, (byte?) range.Start.Value, (byte?) range.End.Value, directory, cancellation);

      default:
        var totalRange = ranges.ToRange();
        var bytes = size.Objects(() => (byte) totalRange.Random());
        
        var file = random.File(directory);

        try
        {
          await bytes.WriteTo(file, cancellation);
        }
        catch
        {
          file.Delete();
        }

        return file;
    }
  }

  /// <summary>
  ///   <para></para>
  /// </summary>
  /// <param name="random"></param>
  /// <param name="size"></param>
  /// <param name="count"></param>
  /// <param name="min"></param>
  /// <param name="max"></param>
  /// <param name="directory"></param>
  /// <param name="cancellation"></param>
  /// <returns></returns>
  public static async IAsyncEnumerable<FileInfo> BinaryFileSequence(this Random random, int size, int count, byte? min = null, byte? max = null, DirectoryInfo directory = null, [EnumeratorCancellation] CancellationToken cancellation = default)
  {
    for (var i = 1; i <= count; i++)
    {
      yield return await random.BinaryFile(size, min, max, directory, cancellation);
    }
  }

  /// <summary>
  ///   <para></para>
  /// </summary>
  /// <param name="random"></param>
  /// <param name="size"></param>
  /// <param name="count"></param>
  /// <param name="directory"></param>
  /// <param name="cancellation"></param>
  /// <param name="ranges"></param>
  /// <returns></returns>
  public static async IAsyncEnumerable<FileInfo> BinaryFileSequenceInRange(this Random random, int size, int count, DirectoryInfo directory = null, [EnumeratorCancellation] CancellationToken cancellation = default, params Range[] ranges)
  {
    if (count <= 0)
    {
      yield break;
    }

    switch (ranges.Length)
    {
      case 0:
        await foreach (var file in random.BinaryFileSequence(size, count, null, null, directory, cancellation))
        {
          yield return file;
        }

        break;

      case 1:
        var range = ranges.First();

        await foreach (var file in random.BinaryFileSequence(size, count, (byte?) range.Start.Value, (byte?) range.End.Value, directory, cancellation))
        {
          yield return file;
        }

        break;

      default:
        var totalRange = ranges.ToRange();

        for (var i = 1; i <= count; i++)
        {
          var bytes = size.Objects(() => (byte) totalRange.Random());

          var file = random.File(directory);

          try
          {
            await bytes.WriteTo(file, cancellation);
          }
          catch
          {
            file.Delete();
          }

          yield return file;
        }

        break;
    }
  }

  /// <summary>
  ///   <para></para>
  /// </summary>
  /// <param name="random"></param>
  /// <param name="size"></param>
  /// <param name="encoding"></param>
  /// <param name="min"></param>
  /// <param name="max"></param>
  /// <param name="directory"></param>
  /// <param name="cancellation"></param>
  /// <returns></returns>
  public static async Task<FileInfo> TextFile(this Random random, int size, Encoding encoding = null, char? min = null, char? max = null, DirectoryInfo directory = null, CancellationToken cancellation = default)
  {
    if (size <= 0)
    {
      return random.File(directory);
    }

    var text = random.String(size, min, max);

    return await random.File(directory).WriteText(text, encoding, cancellation);
  }

  /// <summary>
  ///   <para></para>
  /// </summary>
  /// <param name="random"></param>
  /// <param name="size"></param>
  /// <param name="encoding"></param>
  /// <param name="directory"></param>
  /// <param name="cancellation"></param>
  /// <param name="ranges"></param>
  /// <returns></returns>
  public static async Task<FileInfo> TextFileInRange(this Random random, int size, Encoding encoding = null, DirectoryInfo directory = null, CancellationToken cancellation = default, params Range[] ranges)
  {
    if (size <= 0)
    {
      return await random.TextFile(size, encoding, null, null, directory, cancellation);
    }

    switch (ranges.Length)
    {
      case 0:
        return await random.TextFile(size, encoding, null, null, directory, cancellation);

      case 1:
        var range = ranges.First();
        return await random.TextFile(size, encoding, (char?) range.Start.Value, (char?) range.End.Value, directory, cancellation);

      default:
        var totalRange = ranges.ToRange();
        var chars = size.Objects(() => (char) totalRange.Random()).AsArray();
        return await random.File(directory).WriteText(chars.ToText(), encoding, cancellation);
    }
  }

  /// <summary>
  ///   <para></para>
  /// </summary>
  /// <param name="random"></param>
  /// <param name="size"></param>
  /// <param name="count"></param>
  /// <param name="encoding"></param>
  /// <param name="min"></param>
  /// <param name="max"></param>
  /// <param name="directory"></param>
  /// <param name="cancellation"></param>
  /// <returns></returns>
  public static async IAsyncEnumerable<FileInfo> TextFileSequence(this Random random, int size, int count, Encoding encoding = null, char? min = null, char? max = null, DirectoryInfo directory = null, [EnumeratorCancellation] CancellationToken cancellation = default)
  {
    for (var i = 1; i <= count; i++)
    {
      yield return await random.TextFile(size, encoding, min, max, directory, cancellation);
    }
  }

  /// <summary>
  ///   <para></para>
  /// </summary>
  /// <param name="random"></param>
  /// <param name="size"></param>
  /// <param name="count"></param>
  /// <param name="encoding"></param>
  /// <param name="directory"></param>
  /// <param name="cancellation"></param>
  /// <param name="ranges"></param>
  /// <returns></returns>
  public static async IAsyncEnumerable<FileInfo> TextFileSequenceInRange(this Random random, int size, int count, Encoding encoding = null, DirectoryInfo directory = null, [EnumeratorCancellation] CancellationToken cancellation = default, params Range[] ranges)
  {
    if (count <= 0)
    {
      yield break;
    }

    switch (ranges.Length)
    {
      case 0:
        await foreach (var file in random.TextFileSequence(size, count, encoding, null, null, directory, cancellation))
        {
          yield return file;
        }

        break;

      case 1:
        var range = ranges.First();

        await foreach (var file in random.TextFileSequence(size, count, encoding, (char?) range.Start.Value, (char?) range.End.Value, directory, cancellation))
        {
          yield return file;
        }

        break;

      default:
        var totalRange = ranges.ToRange();

        for (var i = 1; i <= count; i++)
        {
          var chars = size.Objects(() => (char) totalRange.Random()).AsArray();
          yield return await random.File(directory).WriteText(chars.ToText(), encoding, cancellation);
        }

        break;
    }
  }

#if NET6_0
  /// <summary>
  ///   <para></para>
  /// </summary>
  /// <param name="random"></param>
  /// <param name="min"></param>
  /// <param name="max"></param>
  /// <returns></returns>
  public static IPAddress IpAddress(this Random random, uint? min = null, uint? max = null) => new(random.Uint(min, max));

  /// <summary>
  ///   <para></para>
  /// </summary>
  /// <param name="random"></param>
  /// <param name="ranges"></param>
  /// <returns></returns>
  public static IPAddress IpAddressInRange(this Random random, params Range[] ranges)
  {
    switch (ranges.Length)
    {
      case 0:
        return random.IpAddress();

      case 1:
        var range = ranges.First();
        return random.IpAddress((uint?) range.Start.Value, (uint?) range.End.Value);

      default:
        return new IPAddress((uint) ranges.ToRange().Random());
    }
  }

  /// <summary>
  ///   <para></para>
  /// </summary>
  /// <param name="random"></param>
  /// <param name="count"></param>
  /// <param name="min"></param>
  /// <param name="max"></param>
  /// <returns></returns>
  public static IEnumerable<IPAddress> IpAddressSequence(this Random random, int count, uint? min = null, uint? max = null) => count.Objects(() => random.IpAddress(min, max));

  /// <summary>
  ///   <para></para>
  /// </summary>
  /// <param name="random"></param>
  /// <param name="count"></param>
  /// <param name="ranges"></param>
  /// <returns></returns>
  public static IEnumerable<IPAddress> IpAddressSequenceInRange(this Random random, int count, params Range[] ranges)
  {
    if (count <= 0)
    {
      return Enumerable.Empty<IPAddress>();
    }

    switch (ranges.Length)
    {
      case 0:
        return random.IpAddressSequence(count);

      case 1:
        var range = ranges.First();
        return random.IpAddressSequence(count, (uint) range.Start.Value, (uint) range.End.Value);

      default:
        var totalRange = ranges.ToRange();
        return count.Objects(() => new IPAddress((uint) totalRange.Random()));
    }
  }
#endif

  /// <summary>
  ///   <para></para>
  /// </summary>
  /// <param name="random"></param>
  /// <returns></returns>
  public static IPAddress IpV6Address(this Random random) => new(random.Guid().ToByteArray());

  /// <summary>
  ///   <para></para>
  /// </summary>
  /// <param name="random"></param>
  /// <param name="count"></param>
  /// <returns></returns>
  public static IEnumerable<IPAddress> IpV6AddressSequence(this Random random, int count) => count.Objects(random.IpV6Address);

  /// <summary>
  ///   <para></para>
  /// </summary>
  /// <param name="random"></param>
  /// <param name="size"></param>
  /// <param name="min"></param>
  /// <param name="max"></param>
  /// <returns></returns>
  public static PhysicalAddress PhysicalAddress(this Random random, int size, byte? min = null, byte? max = null) => new(random.ByteSequence(size, min, max).AsArray());

  /// <summary>
  ///   <para></para>
  /// </summary>
  /// <param name="random"></param>
  /// <param name="size"></param>
  /// <param name="ranges"></param>
  /// <returns></returns>
  public static PhysicalAddress PhysicalAddressInRange(this Random random, int size, params Range[] ranges)
  {
    switch (ranges.Length)
    {
      case 0:
        return random.PhysicalAddress(size);

      case 1:
        var range = ranges.First();
        return random.PhysicalAddress(size, (byte?) range.Start.Value, (byte?) range.End.Value);

      default:
        return new PhysicalAddress(random.ByteSequenceInRange(size, ranges).AsArray());
    }
  }

  /// <summary>
  ///   <para></para>
  /// </summary>
  /// <param name="random"></param>
  /// <param name="count"></param>
  /// <param name="size"></param>
  /// <param name="min"></param>
  /// <param name="max"></param>
  /// <returns></returns>
  public static IEnumerable<PhysicalAddress> PhysicalAddressSequence(this Random random, int count, int size, byte? min = null, byte? max = null) => count.Objects(() => random.PhysicalAddress(size, min, max));

  /// <summary>
  ///   <para></para>
  /// </summary>
  /// <param name="random"></param>
  /// <param name="count"></param>
  /// <param name="size"></param>
  /// <param name="ranges"></param>
  /// <returns></returns>
  public static IEnumerable<PhysicalAddress> PhysicalAddressSequenceInRange(this Random random, int count, int size, params Range[] ranges)
  {
    if (count <= 0)
    {
      return Enumerable.Empty<PhysicalAddress>();
    }

    switch (ranges.Length)
    {
      case 0:
        return random.PhysicalAddressSequence(count, size);

      case 1:
        var range = ranges.First();
        return random.PhysicalAddressSequence(count, size, (byte?) range.Start.Value, (byte?) range.End.Value);

      default:
        var totalRange = ranges.ToRange();
        return count.Objects(() => new PhysicalAddress(new byte[size].Fill(() => (byte) totalRange.Random()).AsArray()));
    }
  }

  /// <summary>
  ///   <para></para>
  /// </summary>
  /// <param name="random"></param>
  /// <param name="count"></param>
  /// <param name="min"></param>
  /// <param name="max"></param>
  /// <param name="cancellation"></param>
  /// <returns></returns>
  public static async Task<MemoryStream> MemoryStream(this Random random, int count, byte? min = null, byte? max = null, CancellationToken cancellation = default)
  {
    var stream = new MemoryStream();

    if (count > 0)
    {
      (await stream.WriteBytes(random.ByteSequence(count, min, max), cancellation)).MoveToStart();
    }

    return stream;
  }

  /// <summary>
  ///   <para></para>
  /// </summary>
  /// <param name="random"></param>
  /// <param name="count"></param>
  /// <param name="cancellation"></param>
  /// <param name="ranges"></param>
  /// <returns></returns>
  public static async Task<MemoryStream> MemoryStreamInRange(this Random random, int count, CancellationToken cancellation = default, params Range[] ranges)
  {
    var stream = new MemoryStream();

    if (count > 0)
    {
      var range = ranges.ToRange();
      var bytes = (range.Any() ? count.Objects(() => (byte) range.Random()) : random.ByteSequence(count)).AsArray();

      (await stream.WriteBytes(bytes, cancellation)).MoveToStart();
    }

    return stream;
  }

  /// <summary>
  ///   <para></para>
  /// </summary>
  /// <param name="random"></param>
  /// <param name="min"></param>
  /// <param name="max"></param>
  /// <returns></returns>
  public static Stream Stream(this Random random, byte? min = null, byte? max = null) => new RandomStream(min, max);

  /// <summary>
  ///   <para></para>
  /// </summary>
  /// <param name="random"></param>
  /// <param name="ranges"></param>
  /// <returns></returns>
  public static Stream StreamInRange(this Random random, params Range[] ranges) => new RandomRangeStream(ranges);

  private sealed class RandomStream : Stream
  {
    private readonly byte? min;
    private readonly byte? max;

    private Random Randomizer { get; } = new();

    public RandomStream(byte? min = null, byte? max = null)
    {
      this.min = min;
      this.max = max;
    }

    public override bool CanRead => true;

    public override bool CanSeek => false;

    public override bool CanWrite => false;

    public override long Length => 0;

    public override long Position
    {
      get => 0;
      set
      {
      }
    }

    public override int Read(byte[] buffer, int offset, int count)
    {
      buffer.Fill(() => Randomizer.Byte(min, max), offset, count);
      return count;
    }

    public override void Write(byte[] buffer, int offset, int count)
    {
      throw new NotSupportedException();
    }

    public override long Seek(long offset, SeekOrigin origin) => throw new NotSupportedException();

    public override void SetLength(long value) => throw new NotSupportedException();

    public override void Flush()
    {
    }
  }

  private sealed class RandomRangeStream : Stream
  {
    private readonly IEnumerable<int> range;

    private Random Randomizer { get; } = new();

    public RandomRangeStream(params Range[] ranges) => range = ranges.ToRange();

    public override bool CanRead => true;

    public override bool CanSeek => false;

    public override bool CanWrite => false;

    public override long Length => 0;

    public override long Position
    {
      get => 0;
      set
      {
      }
    }

    public override int Read(byte[] buffer, int offset, int count)
    {
      buffer.Fill(() => range.Any() ? (byte) range.Random() : Randomizer.Byte(), offset, count);
      return count;
    }

    public override void Write(byte[] buffer, int offset, int count)
    {
      throw new NotSupportedException();
    }

    public override long Seek(long offset, SeekOrigin origin) => throw new NotSupportedException();

    public override void SetLength(long value) => throw new NotSupportedException();

    public override void Flush()
    {
    }
  }
}